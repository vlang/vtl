var searchModuleIndex = ["README","autograd","datasets","la","ml.metrics","nn.gates.activation","nn.gates.layers","nn.gates.loss","nn.internal","nn.layers","nn.loss","nn.models","nn.optimizers","nn.types","vtl","stats","storage",];
var searchIndex = ["Context","ctx","Context[T]","len","push","last","pop","variable","str","ContextVariableData","register","CacheParam","Gate","gate_backward","gate_cache","AddGate","add_gate","AddGate[T]","backward","cache","SubstractGate","subtract_gate","SubstractGate[T]","backward","cache","MultiplyGate","multiply_gate","MultiplyGate[T]","backward","cache","DivideGate","divide_gate","DivideGate[T]","backward","cache","MatMulGate","matmul_gate","MatMulGate[T]","backward","cache","ExpGate","exp_gate","ExpGate[T]","backward","cache","PowGate","pow_gate","PowGate[T]","backward","cache","SinGate","sin_gate","SinGate[T]","backward","cache","CosGate","cos_gate","CosGate[T]","backward","cache","TanGate","tan_gate","TanGate[T]","backward","cache","Node","node","Payload","payload","Variable","VariableData","variable","Variable[T]","add","backprop","cos","divide","exp","is_grad_needed","matmul","multiply","pow","sin","slice","slice_hilo","str","subtract","tan","ImdbDataset","load_imdb","MnistDataset","load_mnist","dot","det","inv","matmul","accuracy_score","squared_error","mean_squared_error","relative_error","mean_relative_error","absolute_error","mean_absolute_error","EluGate","elu_gate","EluGate[T]","backward","cache","LeakyReluGate","leaky_relu_gate","LeakyReluGate[T]","backward","cache","ReLUGate","relu_gate","ReLUGate[T]","backward","cache","SigmoidGate","sigmoid_gate","SigmoidGate[T]","backward","cache","DropoutGate","dropout_gate","DropoutGate[T]","backward","cache","FlattenGate","flatten_gate","FlattenGate[T]","backward","cache","InputGate","input_gate","InputGate[T]","backward","cache","LinearGate","linear_gate","LinearGate[T]","backward","cache","MaxPool2DGate","maxpool2d_gate","MaxPool2DGate[T]","backward","cache","MseGate","mse_gate","MseGate[T]","backward","cache","SigmoidCrossEntropyGate","sigmoid_cross_entropy_gate","SigmoidCrossEntropyGate[T]","backward","cache","SoftmaxCrossEntropyGate","softmax_cross_entropy_gate","SoftmaxCrossEntropyGate[T]","backward","cache","tanh","deriv_tanh","sigmoid","deriv_sigmoid","relu","deriv_relu","leaky_relu","deriv_leaky_relu","elu","deriv_elu","sigmoid_cross_entropy","mse","FanMode","Distribution","compute_fans","variance_scaled","kaiming_uniform","kaiming_normal","dropout","dropout_backwards","maxpool2d","maxpool2d_backward","mse_backward","sigmoid_cross_entropy_backward","softmax_cross_entropy_backward","sgd_optimize","DropoutLayerConfig","DropoutLayer","dropout_layer","DropoutLayer[T]","output_shape","variables","forward","EluLayerConfig","EluLayer","elu_layer","EluLayer[T]","output_shape","variables","forward","FlattenLayer","flatten_layer","FlattenLayer[T]","output_shape","variables","forward","InputLayer","input_layer","InputLayer[T]","output_shape","variables","forward","LeakyReluLayer","leaky_relu_layer","LeakyReluLayer[T]","output_shape","variables","forward","LinearLayer","linear_layer","LinearLayer[T]","output_shape","variables","forward","MaxPool2DLayer","maxpool2d_layer","MaxPool2DLayer[T]","output_shape","variables","forward","ReLULayer","relu_layer","ReLULayer[T]","output_shape","variables","forward","SigmoidLayer","sigmoid_layer","SigmoidLayer[T]","output_shape","variables","forward","loss_loss","MSELoss","mse_loss","MSELoss[T]","loss","SigmoidCrossEntropyLoss","sigmoid_cross_entropy_loss","SigmoidCrossEntropyLoss[T]","loss","SoftmaxCrossEntropyLoss","softmax_cross_entropy_loss","SoftmaxCrossEntropyLoss[T]","loss","Sequential","sequential","sequential_with_layers","sequential_from_ctx","sequential_from_ctx_with_layers","Sequential[T]","input","linear","maxpool2d","mse_loss","sigmoid_cross_entropy_loss","softmax_cross_entropy_loss","flatten","relu","leaky_relu","elu","sigmod","forward","loss","SequentialInfo","sequential_info","SequentialInfo[T]","input","linear","maxpool2d","mse_loss","sigmoid_cross_entropy_loss","softmax_cross_entropy_loss","flatten","relu","leaky_relu","elu","sigmod","AdamOptimizer","AdamOptimizerConfig","adam_optimizer","AdamOptimizer[T]","build_params","update","SgdOptimizer","SgdOptimizerConfig","sgd","SgdOptimizer[T]","build_params","update","Layer","Loss","Optimizer","Tensor[T]","abs","acos","acosh","add","add_scalar","alike","all","any","apply","array_equal","array_equiv","array_split","array_split_expl","as_bool","as_f32","as_f64","as_i16","as_i8","as_int","as_strided","as_string","as_u8","asin","asinh","assert_matrix","assert_square_matrix","assign","atan","atan2","atanh","axis_iterator","axis_with_dims_iterator","broadcast_to","broadcastable","cbrt","ceil","close","copy","cos","cosh","cot","cpu","custom_iterator","degrees","diag","diag_flat","diagonal","divide","divide_scalar","dsplit","dsplit_expl","ensure_memory","equal","erf","erfc","exp","exp2","expand_dims","expm1","f32_bits","f32_from_bits","f64_bits","f64_from_bits","factorial","fill","floor","fmod","gamma","gcd","get","get_nth","hsplit","hsplit_expl","hypot","is_col_major","is_col_major_contiguous","is_contiguous","is_finite","is_inf","is_matrix","is_nan","is_row_major","is_row_major_contiguous","is_square_matrix","is_vector","iterator","iterators","lcm","log","log10","log1p","log2","log_factorial","log_gamma","log_n","map","max","min","multiply","multiply_scalar","napply","nextafter","nextafter32","nmap","not_equal","nreduce","nth_index","offset_index","pow","pow10","radians","rank","ravel","reduce","reshape","round","round_to_even","set","set_nth","sin","sinh","size","slice","slice_hilo","split","split_expl","sqrt","str","subtract","subtract_scalar","swapaxes","t","tan","tanh","to_array","tolerance","transpose","tril","tril_inpl_offset","tril_inplace","tril_offset","triu","triu_inplace","triu_offset","trunc","unsqueeze","vcl","veryclose","view","vsplit","vsplit_expl","with_broadcast","with_dims","broadcast2","broadcast3","broadcast_n","TensorData","from_array","tensor","tensor_like","tensor_like_with_shape","empty","empty_like","identity","eye","zeros","zeros_like","ones","ones_like","full","full_like","range","seq","from_1d","from_2d","IteratorStrategy","TensorIterator","IteratorBuildData","TensorIterator[T]","next","TensorsIterator","TensorsIterator[T]","next","TensorAxisIterator","TensorAxisIterator[T]","next","bernoulli","binomial","exponential","NormalTensorData","normal","random","random_seed","AxisData","vstack","hstack","dstack","column_stack","stack","concatenate","MemoryFormat","Tensor","TensorDataType","string","int","i64","i8","i16","u8","u16","u32","u64","f32","f64","bool","td","cast","AnyTensor","VclParams","AxisData","sum","sum_axis","sum_axis_with_dims","prod","prod_axis","prod_axis_with_dims","freq","mean","geometric_mean","harmonic_mean","median","mode","rms","population_variance","population_variance_mean","sample_variance","sample_variance_mean","population_stddev","population_stddev_mean","sample_stddev","sample_stddev_mean","absdev","absdev_mean","tss","tss_mean","min","max","minmax","min_index","max_index","minmax_index","range","covariance","covariance_mean","lag1_autocorrelation","lag1_autocorrelation_mean","kurtosis","kurtosis_mean_stddev","skew","skew_mean_stddev","quantile","CpuStorage","storage","from_array","CpuStorage[T]","get","set","fill","clone","like","like_with_len","offset","to_array",];
var searchModuleData = [["","index.html"],["","autograd.html"],["","datasets.html"],["","la.html"],["","ml.metrics.html"],["","nn.gates.activation.html"],["","nn.gates.layers.html"],["","nn.gates.loss.html"],["","nn.internal.html"],["","nn.layers.html"],["","nn.loss.html"],["","nn.models.html"],["","nn.optimizers.html"],["","nn.types.html"],["","vtl.html"],["","stats.html"],["","storage.html"],];
var searchData = [["autograd","","autograd.html#Context","struct "],["autograd","","autograd.html#ctx","fn "],["autograd","","autograd.html#Context[T]","type "],["autograd","","autograd.html#Context[T].len","fn (Context[T])"],["autograd","","autograd.html#Context[T].push","fn (Context[T])"],["autograd","","autograd.html#Context[T].last","fn (Context[T])"],["autograd","","autograd.html#Context[T].pop","fn (Context[T])"],["autograd","","autograd.html#Context[T].variable","fn (Context[T])"],["autograd","","autograd.html#Context[T].str","fn (Context[T])"],["autograd","","autograd.html#ContextVariableData","struct "],["autograd","","autograd.html#register","fn "],["autograd","","autograd.html#CacheParam","interface "],["autograd","","autograd.html#Gate","interface "],["autograd","","autograd.html#gate_backward","fn "],["autograd","","autograd.html#gate_cache","fn "],["autograd","","autograd.html#AddGate","struct "],["autograd","","autograd.html#add_gate","fn "],["autograd","","autograd.html#AddGate[T]","type "],["autograd","","autograd.html#AddGate[T].backward","fn (AddGate[T])"],["autograd","","autograd.html#AddGate[T].cache","fn (AddGate[T])"],["autograd","","autograd.html#SubstractGate","struct "],["autograd","","autograd.html#subtract_gate","fn "],["autograd","","autograd.html#SubstractGate[T]","type "],["autograd","","autograd.html#SubstractGate[T].backward","fn (SubstractGate[T])"],["autograd","","autograd.html#SubstractGate[T].cache","fn (SubstractGate[T])"],["autograd","","autograd.html#MultiplyGate","struct "],["autograd","","autograd.html#multiply_gate","fn "],["autograd","","autograd.html#MultiplyGate[T]","type "],["autograd","","autograd.html#MultiplyGate[T].backward","fn (MultiplyGate[T])"],["autograd","","autograd.html#MultiplyGate[T].cache","fn (MultiplyGate[T])"],["autograd","","autograd.html#DivideGate","struct "],["autograd","","autograd.html#divide_gate","fn "],["autograd","","autograd.html#DivideGate[T]","type "],["autograd","","autograd.html#DivideGate[T].backward","fn (DivideGate[T])"],["autograd","","autograd.html#DivideGate[T].cache","fn (DivideGate[T])"],["autograd","","autograd.html#MatMulGate","struct "],["autograd","","autograd.html#matmul_gate","fn "],["autograd","","autograd.html#MatMulGate[T]","type "],["autograd","","autograd.html#MatMulGate[T].backward","fn (MatMulGate[T])"],["autograd","","autograd.html#MatMulGate[T].cache","fn (MatMulGate[T])"],["autograd","","autograd.html#ExpGate","struct "],["autograd","","autograd.html#exp_gate","fn "],["autograd","","autograd.html#ExpGate[T]","type "],["autograd","","autograd.html#ExpGate[T].backward","fn (ExpGate[T])"],["autograd","","autograd.html#ExpGate[T].cache","fn (ExpGate[T])"],["autograd","","autograd.html#PowGate","struct "],["autograd","","autograd.html#pow_gate","fn "],["autograd","","autograd.html#PowGate[T]","type "],["autograd","","autograd.html#PowGate[T].backward","fn (PowGate[T])"],["autograd","","autograd.html#PowGate[T].cache","fn (PowGate[T])"],["autograd","","autograd.html#SinGate","struct "],["autograd","","autograd.html#sin_gate","fn "],["autograd","","autograd.html#SinGate[T]","type "],["autograd","","autograd.html#SinGate[T].backward","fn (SinGate[T])"],["autograd","","autograd.html#SinGate[T].cache","fn (SinGate[T])"],["autograd","","autograd.html#CosGate","struct "],["autograd","","autograd.html#cos_gate","fn "],["autograd","","autograd.html#CosGate[T]","type "],["autograd","","autograd.html#CosGate[T].backward","fn (CosGate[T])"],["autograd","","autograd.html#CosGate[T].cache","fn (CosGate[T])"],["autograd","","autograd.html#TanGate","struct "],["autograd","","autograd.html#tan_gate","fn "],["autograd","","autograd.html#TanGate[T]","type "],["autograd","","autograd.html#TanGate[T].backward","fn (TanGate[T])"],["autograd","","autograd.html#TanGate[T].cache","fn (TanGate[T])"],["autograd","","autograd.html#Node","struct "],["autograd","","autograd.html#node","fn "],["autograd","","autograd.html#Payload","struct "],["autograd","","autograd.html#payload","fn "],["autograd","","autograd.html#Variable","struct "],["autograd","","autograd.html#VariableData","struct "],["autograd","","autograd.html#variable","fn "],["autograd","","autograd.html#Variable[T]","type "],["autograd","","autograd.html#Variable[T].add","fn (Variable[T])"],["autograd","","autograd.html#Variable[T].backprop","fn (Variable[T])"],["autograd","","autograd.html#Variable[T].cos","fn (Variable[T])"],["autograd","","autograd.html#Variable[T].divide","fn (Variable[T])"],["autograd","","autograd.html#Variable[T].exp","fn (Variable[T])"],["autograd","","autograd.html#Variable[T].is_grad_needed","fn (Variable[T])"],["autograd","","autograd.html#Variable[T].matmul","fn (Variable[T])"],["autograd","","autograd.html#Variable[T].multiply","fn (Variable[T])"],["autograd","","autograd.html#Variable[T].pow","fn (Variable[T])"],["autograd","","autograd.html#Variable[T].sin","fn (Variable[T])"],["autograd","","autograd.html#Variable[T].slice","fn (Variable[T])"],["autograd","","autograd.html#Variable[T].slice_hilo","fn (Variable[T])"],["autograd","","autograd.html#Variable[T].str","fn (Variable[T])"],["autograd","","autograd.html#Variable[T].subtract","fn (Variable[T])"],["autograd","","autograd.html#Variable[T].tan","fn (Variable[T])"],["datasets","","datasets.html#ImdbDataset","struct "],["datasets","","datasets.html#load_imdb","fn "],["datasets","","datasets.html#MnistDataset","struct "],["datasets","","datasets.html#load_mnist","fn "],["la","","la.html#dot","fn "],["la","","la.html#det","fn "],["la","","la.html#inv","fn "],["la","","la.html#matmul","fn "],["ml.metrics","","ml.metrics.html#accuracy_score","fn "],["ml.metrics","","ml.metrics.html#squared_error","fn "],["ml.metrics","","ml.metrics.html#mean_squared_error","fn "],["ml.metrics","","ml.metrics.html#relative_error","fn "],["ml.metrics","","ml.metrics.html#mean_relative_error","fn "],["ml.metrics","","ml.metrics.html#absolute_error","fn "],["ml.metrics","","ml.metrics.html#mean_absolute_error","fn "],["nn.gates.activation","","nn.gates.activation.html#EluGate","struct "],["nn.gates.activation","","nn.gates.activation.html#elu_gate","fn "],["nn.gates.activation","","nn.gates.activation.html#EluGate[T]","type "],["nn.gates.activation","","nn.gates.activation.html#EluGate[T].backward","fn (EluGate[T])"],["nn.gates.activation","","nn.gates.activation.html#EluGate[T].cache","fn (EluGate[T])"],["nn.gates.activation","","nn.gates.activation.html#LeakyReluGate","struct "],["nn.gates.activation","","nn.gates.activation.html#leaky_relu_gate","fn "],["nn.gates.activation","","nn.gates.activation.html#LeakyReluGate[T]","type "],["nn.gates.activation","","nn.gates.activation.html#LeakyReluGate[T].backward","fn (LeakyReluGate[T])"],["nn.gates.activation","","nn.gates.activation.html#LeakyReluGate[T].cache","fn (LeakyReluGate[T])"],["nn.gates.activation","","nn.gates.activation.html#ReLUGate","struct "],["nn.gates.activation","","nn.gates.activation.html#relu_gate","fn "],["nn.gates.activation","","nn.gates.activation.html#ReLUGate[T]","type "],["nn.gates.activation","","nn.gates.activation.html#ReLUGate[T].backward","fn (ReLUGate[T])"],["nn.gates.activation","","nn.gates.activation.html#ReLUGate[T].cache","fn (ReLUGate[T])"],["nn.gates.activation","","nn.gates.activation.html#SigmoidGate","struct "],["nn.gates.activation","","nn.gates.activation.html#sigmoid_gate","fn "],["nn.gates.activation","","nn.gates.activation.html#SigmoidGate[T]","type "],["nn.gates.activation","","nn.gates.activation.html#SigmoidGate[T].backward","fn (SigmoidGate[T])"],["nn.gates.activation","","nn.gates.activation.html#SigmoidGate[T].cache","fn (SigmoidGate[T])"],["nn.gates.layers","","nn.gates.layers.html#DropoutGate","struct "],["nn.gates.layers","","nn.gates.layers.html#dropout_gate","fn "],["nn.gates.layers","","nn.gates.layers.html#DropoutGate[T]","type "],["nn.gates.layers","","nn.gates.layers.html#DropoutGate[T].backward","fn (DropoutGate[T])"],["nn.gates.layers","","nn.gates.layers.html#DropoutGate[T].cache","fn (DropoutGate[T])"],["nn.gates.layers","","nn.gates.layers.html#FlattenGate","struct "],["nn.gates.layers","","nn.gates.layers.html#flatten_gate","fn "],["nn.gates.layers","","nn.gates.layers.html#FlattenGate[T]","type "],["nn.gates.layers","","nn.gates.layers.html#FlattenGate[T].backward","fn (FlattenGate[T])"],["nn.gates.layers","","nn.gates.layers.html#FlattenGate[T].cache","fn (FlattenGate[T])"],["nn.gates.layers","","nn.gates.layers.html#InputGate","struct "],["nn.gates.layers","","nn.gates.layers.html#input_gate","fn "],["nn.gates.layers","","nn.gates.layers.html#InputGate[T]","type "],["nn.gates.layers","","nn.gates.layers.html#InputGate[T].backward","fn (InputGate[T])"],["nn.gates.layers","","nn.gates.layers.html#InputGate[T].cache","fn (InputGate[T])"],["nn.gates.layers","","nn.gates.layers.html#LinearGate","struct "],["nn.gates.layers","","nn.gates.layers.html#linear_gate","fn "],["nn.gates.layers","","nn.gates.layers.html#LinearGate[T]","type "],["nn.gates.layers","","nn.gates.layers.html#LinearGate[T].backward","fn (LinearGate[T])"],["nn.gates.layers","","nn.gates.layers.html#LinearGate[T].cache","fn (LinearGate[T])"],["nn.gates.layers","","nn.gates.layers.html#MaxPool2DGate","struct "],["nn.gates.layers","","nn.gates.layers.html#maxpool2d_gate","fn "],["nn.gates.layers","","nn.gates.layers.html#MaxPool2DGate[T]","type "],["nn.gates.layers","","nn.gates.layers.html#MaxPool2DGate[T].backward","fn (MaxPool2DGate[T])"],["nn.gates.layers","","nn.gates.layers.html#MaxPool2DGate[T].cache","fn (MaxPool2DGate[T])"],["nn.gates.loss","","nn.gates.loss.html#MseGate","struct "],["nn.gates.loss","","nn.gates.loss.html#mse_gate","fn "],["nn.gates.loss","","nn.gates.loss.html#MseGate[T]","type "],["nn.gates.loss","","nn.gates.loss.html#MseGate[T].backward","fn (MseGate[T])"],["nn.gates.loss","","nn.gates.loss.html#MseGate[T].cache","fn (MseGate[T])"],["nn.gates.loss","","nn.gates.loss.html#SigmoidCrossEntropyGate","struct "],["nn.gates.loss","","nn.gates.loss.html#sigmoid_cross_entropy_gate","fn "],["nn.gates.loss","","nn.gates.loss.html#SigmoidCrossEntropyGate[T]","type "],["nn.gates.loss","","nn.gates.loss.html#SigmoidCrossEntropyGate[T].backward","fn (SigmoidCrossEntropyGate[T])"],["nn.gates.loss","","nn.gates.loss.html#SigmoidCrossEntropyGate[T].cache","fn (SigmoidCrossEntropyGate[T])"],["nn.gates.loss","","nn.gates.loss.html#SoftmaxCrossEntropyGate","struct "],["nn.gates.loss","","nn.gates.loss.html#softmax_cross_entropy_gate","fn "],["nn.gates.loss","","nn.gates.loss.html#SoftmaxCrossEntropyGate[T]","type "],["nn.gates.loss","","nn.gates.loss.html#SoftmaxCrossEntropyGate[T].backward","fn (SoftmaxCrossEntropyGate[T])"],["nn.gates.loss","","nn.gates.loss.html#SoftmaxCrossEntropyGate[T].cache","fn (SoftmaxCrossEntropyGate[T])"],["nn.internal","","nn.internal.html#tanh","fn "],["nn.internal","","nn.internal.html#deriv_tanh","fn "],["nn.internal","","nn.internal.html#sigmoid","fn "],["nn.internal","","nn.internal.html#deriv_sigmoid","fn "],["nn.internal","","nn.internal.html#relu","fn "],["nn.internal","","nn.internal.html#deriv_relu","fn "],["nn.internal","","nn.internal.html#leaky_relu","fn "],["nn.internal","","nn.internal.html#deriv_leaky_relu","fn "],["nn.internal","","nn.internal.html#elu","fn "],["nn.internal","","nn.internal.html#deriv_elu","fn "],["nn.internal","","nn.internal.html#sigmoid_cross_entropy","fn "],["nn.internal","","nn.internal.html#mse","fn "],["nn.internal","","nn.internal.html#FanMode","enum "],["nn.internal","","nn.internal.html#Distribution","enum "],["nn.internal","","nn.internal.html#compute_fans","fn "],["nn.internal","","nn.internal.html#variance_scaled","fn "],["nn.internal","","nn.internal.html#kaiming_uniform","fn "],["nn.internal","","nn.internal.html#kaiming_normal","fn "],["nn.internal","","nn.internal.html#dropout","fn "],["nn.internal","","nn.internal.html#dropout_backwards","fn "],["nn.internal","","nn.internal.html#maxpool2d","fn "],["nn.internal","","nn.internal.html#maxpool2d_backward","fn "],["nn.internal","","nn.internal.html#mse_backward","fn "],["nn.internal","","nn.internal.html#sigmoid_cross_entropy_backward","fn "],["nn.internal","","nn.internal.html#softmax_cross_entropy_backward","fn "],["nn.internal","","nn.internal.html#sgd_optimize","fn "],["nn.layers","","nn.layers.html#DropoutLayerConfig","struct "],["nn.layers","","nn.layers.html#DropoutLayer","struct "],["nn.layers","","nn.layers.html#dropout_layer","fn "],["nn.layers","","nn.layers.html#DropoutLayer[T]","type "],["nn.layers","","nn.layers.html#DropoutLayer[T].output_shape","fn (DropoutLayer[T])"],["nn.layers","","nn.layers.html#DropoutLayer[T].variables","fn (DropoutLayer[T])"],["nn.layers","","nn.layers.html#DropoutLayer[T].forward","fn (DropoutLayer[T])"],["nn.layers","","nn.layers.html#EluLayerConfig","struct "],["nn.layers","","nn.layers.html#EluLayer","struct "],["nn.layers","","nn.layers.html#elu_layer","fn "],["nn.layers","","nn.layers.html#EluLayer[T]","type "],["nn.layers","","nn.layers.html#EluLayer[T].output_shape","fn (EluLayer[T])"],["nn.layers","","nn.layers.html#EluLayer[T].variables","fn (EluLayer[T])"],["nn.layers","","nn.layers.html#EluLayer[T].forward","fn (EluLayer[T])"],["nn.layers","","nn.layers.html#FlattenLayer","struct "],["nn.layers","","nn.layers.html#flatten_layer","fn "],["nn.layers","","nn.layers.html#FlattenLayer[T]","type "],["nn.layers","","nn.layers.html#FlattenLayer[T].output_shape","fn (FlattenLayer[T])"],["nn.layers","","nn.layers.html#FlattenLayer[T].variables","fn (FlattenLayer[T])"],["nn.layers","","nn.layers.html#FlattenLayer[T].forward","fn (FlattenLayer[T])"],["nn.layers","","nn.layers.html#InputLayer","struct "],["nn.layers","","nn.layers.html#input_layer","fn "],["nn.layers","","nn.layers.html#InputLayer[T]","type "],["nn.layers","","nn.layers.html#InputLayer[T].output_shape","fn (InputLayer[T])"],["nn.layers","","nn.layers.html#InputLayer[T].variables","fn (InputLayer[T])"],["nn.layers","","nn.layers.html#InputLayer[T].forward","fn (InputLayer[T])"],["nn.layers","","nn.layers.html#LeakyReluLayer","struct "],["nn.layers","","nn.layers.html#leaky_relu_layer","fn "],["nn.layers","","nn.layers.html#LeakyReluLayer[T]","type "],["nn.layers","","nn.layers.html#LeakyReluLayer[T].output_shape","fn (LeakyReluLayer[T])"],["nn.layers","","nn.layers.html#LeakyReluLayer[T].variables","fn (LeakyReluLayer[T])"],["nn.layers","","nn.layers.html#LeakyReluLayer[T].forward","fn (LeakyReluLayer[T])"],["nn.layers","","nn.layers.html#LinearLayer","struct "],["nn.layers","","nn.layers.html#linear_layer","fn "],["nn.layers","","nn.layers.html#LinearLayer[T]","type "],["nn.layers","","nn.layers.html#LinearLayer[T].output_shape","fn (LinearLayer[T])"],["nn.layers","","nn.layers.html#LinearLayer[T].variables","fn (LinearLayer[T])"],["nn.layers","","nn.layers.html#LinearLayer[T].forward","fn (LinearLayer[T])"],["nn.layers","","nn.layers.html#MaxPool2DLayer","struct "],["nn.layers","","nn.layers.html#maxpool2d_layer","fn "],["nn.layers","","nn.layers.html#MaxPool2DLayer[T]","type "],["nn.layers","","nn.layers.html#MaxPool2DLayer[T].output_shape","fn (MaxPool2DLayer[T])"],["nn.layers","","nn.layers.html#MaxPool2DLayer[T].variables","fn (MaxPool2DLayer[T])"],["nn.layers","","nn.layers.html#MaxPool2DLayer[T].forward","fn (MaxPool2DLayer[T])"],["nn.layers","","nn.layers.html#ReLULayer","struct "],["nn.layers","","nn.layers.html#relu_layer","fn "],["nn.layers","","nn.layers.html#ReLULayer[T]","type "],["nn.layers","","nn.layers.html#ReLULayer[T].output_shape","fn (ReLULayer[T])"],["nn.layers","","nn.layers.html#ReLULayer[T].variables","fn (ReLULayer[T])"],["nn.layers","","nn.layers.html#ReLULayer[T].forward","fn (ReLULayer[T])"],["nn.layers","","nn.layers.html#SigmoidLayer","struct "],["nn.layers","","nn.layers.html#sigmoid_layer","fn "],["nn.layers","","nn.layers.html#SigmoidLayer[T]","type "],["nn.layers","","nn.layers.html#SigmoidLayer[T].output_shape","fn (SigmoidLayer[T])"],["nn.layers","","nn.layers.html#SigmoidLayer[T].variables","fn (SigmoidLayer[T])"],["nn.layers","","nn.layers.html#SigmoidLayer[T].forward","fn (SigmoidLayer[T])"],["nn.loss","","nn.loss.html#loss_loss","fn "],["nn.loss","","nn.loss.html#MSELoss","struct "],["nn.loss","","nn.loss.html#mse_loss","fn "],["nn.loss","","nn.loss.html#MSELoss[T]","type "],["nn.loss","","nn.loss.html#MSELoss[T].loss","fn (MSELoss[T])"],["nn.loss","","nn.loss.html#SigmoidCrossEntropyLoss","struct "],["nn.loss","","nn.loss.html#sigmoid_cross_entropy_loss","fn "],["nn.loss","","nn.loss.html#SigmoidCrossEntropyLoss[T]","type "],["nn.loss","","nn.loss.html#SigmoidCrossEntropyLoss[T].loss","fn (SigmoidCrossEntropyLoss[T])"],["nn.loss","","nn.loss.html#SoftmaxCrossEntropyLoss","struct "],["nn.loss","","nn.loss.html#softmax_cross_entropy_loss","fn "],["nn.loss","","nn.loss.html#SoftmaxCrossEntropyLoss[T]","type "],["nn.loss","","nn.loss.html#SoftmaxCrossEntropyLoss[T].loss","fn (SoftmaxCrossEntropyLoss[T])"],["nn.models","","nn.models.html#Sequential","struct "],["nn.models","","nn.models.html#sequential","fn "],["nn.models","","nn.models.html#sequential_with_layers","fn "],["nn.models","","nn.models.html#sequential_from_ctx","fn "],["nn.models","","nn.models.html#sequential_from_ctx_with_layers","fn "],["nn.models","","nn.models.html#Sequential[T]","type "],["nn.models","","nn.models.html#Sequential[T].input","fn (Sequential[T])"],["nn.models","","nn.models.html#Sequential[T].linear","fn (Sequential[T])"],["nn.models","","nn.models.html#Sequential[T].maxpool2d","fn (Sequential[T])"],["nn.models","","nn.models.html#Sequential[T].mse_loss","fn (Sequential[T])"],["nn.models","","nn.models.html#Sequential[T].sigmoid_cross_entropy_loss","fn (Sequential[T])"],["nn.models","","nn.models.html#Sequential[T].softmax_cross_entropy_loss","fn (Sequential[T])"],["nn.models","","nn.models.html#Sequential[T].flatten","fn (Sequential[T])"],["nn.models","","nn.models.html#Sequential[T].relu","fn (Sequential[T])"],["nn.models","","nn.models.html#Sequential[T].leaky_relu","fn (Sequential[T])"],["nn.models","","nn.models.html#Sequential[T].elu","fn (Sequential[T])"],["nn.models","","nn.models.html#Sequential[T].sigmod","fn (Sequential[T])"],["nn.models","","nn.models.html#Sequential[T].forward","fn (Sequential[T])"],["nn.models","","nn.models.html#Sequential[T].loss","fn (Sequential[T])"],["nn.models","","nn.models.html#SequentialInfo","struct "],["nn.models","","nn.models.html#sequential_info","fn "],["nn.models","","nn.models.html#SequentialInfo[T]","type "],["nn.models","","nn.models.html#SequentialInfo[T].input","fn (SequentialInfo[T])"],["nn.models","","nn.models.html#SequentialInfo[T].linear","fn (SequentialInfo[T])"],["nn.models","","nn.models.html#SequentialInfo[T].maxpool2d","fn (SequentialInfo[T])"],["nn.models","","nn.models.html#SequentialInfo[T].mse_loss","fn (SequentialInfo[T])"],["nn.models","","nn.models.html#SequentialInfo[T].sigmoid_cross_entropy_loss","fn (SequentialInfo[T])"],["nn.models","","nn.models.html#SequentialInfo[T].softmax_cross_entropy_loss","fn (SequentialInfo[T])"],["nn.models","","nn.models.html#SequentialInfo[T].flatten","fn (SequentialInfo[T])"],["nn.models","","nn.models.html#SequentialInfo[T].relu","fn (SequentialInfo[T])"],["nn.models","","nn.models.html#SequentialInfo[T].leaky_relu","fn (SequentialInfo[T])"],["nn.models","","nn.models.html#SequentialInfo[T].elu","fn (SequentialInfo[T])"],["nn.models","","nn.models.html#SequentialInfo[T].sigmod","fn (SequentialInfo[T])"],["nn.optimizers","","nn.optimizers.html#AdamOptimizer","struct "],["nn.optimizers","","nn.optimizers.html#AdamOptimizerConfig","struct "],["nn.optimizers","","nn.optimizers.html#adam_optimizer","fn "],["nn.optimizers","","nn.optimizers.html#AdamOptimizer[T]","type "],["nn.optimizers","","nn.optimizers.html#AdamOptimizer[T].build_params","fn (AdamOptimizer[T])"],["nn.optimizers","","nn.optimizers.html#AdamOptimizer[T].update","fn (AdamOptimizer[T])"],["nn.optimizers","","nn.optimizers.html#SgdOptimizer","struct "],["nn.optimizers","","nn.optimizers.html#SgdOptimizerConfig","struct "],["nn.optimizers","","nn.optimizers.html#sgd","fn "],["nn.optimizers","","nn.optimizers.html#SgdOptimizer[T]","type "],["nn.optimizers","","nn.optimizers.html#SgdOptimizer[T].build_params","fn (SgdOptimizer[T])"],["nn.optimizers","","nn.optimizers.html#SgdOptimizer[T].update","fn (SgdOptimizer[T])"],["nn.types","","nn.types.html#Layer","interface "],["nn.types","","nn.types.html#Loss","interface "],["nn.types","","nn.types.html#Optimizer","interface "],["vtl","","vtl.html#Tensor[T]","type "],["vtl","","vtl.html#Tensor[T].abs","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].acos","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].acosh","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].add","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].add_scalar","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].alike","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].all","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].any","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].apply","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].array_equal","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].array_equiv","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].array_split","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].array_split_expl","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].as_bool","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].as_f32","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].as_f64","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].as_i16","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].as_i8","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].as_int","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].as_strided","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].as_string","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].as_u8","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].asin","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].asinh","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].assert_matrix","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].assert_square_matrix","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].assign","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].atan","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].atan2","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].atanh","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].axis_iterator","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].axis_with_dims_iterator","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].broadcast_to","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].broadcastable","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].cbrt","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].ceil","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].close","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].copy","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].cos","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].cosh","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].cot","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].cpu","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].custom_iterator","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].degrees","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].diag","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].diag_flat","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].diagonal","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].divide","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].divide_scalar","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].dsplit","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].dsplit_expl","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].ensure_memory","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].equal","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].erf","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].erfc","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].exp","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].exp2","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].expand_dims","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].expm1","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].f32_bits","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].f32_from_bits","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].f64_bits","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].f64_from_bits","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].factorial","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].fill","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].floor","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].fmod","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].gamma","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].gcd","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].get","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].get_nth","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].hsplit","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].hsplit_expl","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].hypot","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].is_col_major","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].is_col_major_contiguous","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].is_contiguous","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].is_finite","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].is_inf","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].is_matrix","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].is_nan","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].is_row_major","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].is_row_major_contiguous","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].is_square_matrix","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].is_vector","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].iterator","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].iterators","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].lcm","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].log","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].log10","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].log1p","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].log2","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].log_factorial","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].log_gamma","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].log_n","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].map","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].max","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].min","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].multiply","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].multiply_scalar","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].napply","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].nextafter","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].nextafter32","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].nmap","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].not_equal","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].nreduce","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].nth_index","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].offset_index","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].pow","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].pow10","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].radians","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].rank","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].ravel","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].reduce","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].reshape","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].round","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].round_to_even","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].set","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].set_nth","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].sin","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].sinh","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].size","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].slice","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].slice_hilo","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].split","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].split_expl","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].sqrt","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].str","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].subtract","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].subtract_scalar","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].swapaxes","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].t","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].tan","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].tanh","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].to_array","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].tolerance","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].transpose","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].tril","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].tril_inpl_offset","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].tril_inplace","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].tril_offset","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].triu","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].triu_inplace","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].triu_offset","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].trunc","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].unsqueeze","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].vcl","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].veryclose","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].view","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].vsplit","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].vsplit_expl","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].with_broadcast","fn (Tensor[T])"],["vtl","","vtl.html#Tensor[T].with_dims","fn (Tensor[T])"],["vtl","","vtl.html#broadcast2","fn "],["vtl","","vtl.html#broadcast3","fn "],["vtl","","vtl.html#broadcast_n","fn "],["vtl","","vtl.html#TensorData","struct "],["vtl","","vtl.html#from_array","fn "],["vtl","","vtl.html#tensor","fn "],["vtl","","vtl.html#tensor_like","fn "],["vtl","","vtl.html#tensor_like_with_shape","fn "],["vtl","","vtl.html#empty","fn "],["vtl","","vtl.html#empty_like","fn "],["vtl","","vtl.html#identity","fn "],["vtl","","vtl.html#eye","fn "],["vtl","","vtl.html#zeros","fn "],["vtl","","vtl.html#zeros_like","fn "],["vtl","","vtl.html#ones","fn "],["vtl","","vtl.html#ones_like","fn "],["vtl","","vtl.html#full","fn "],["vtl","","vtl.html#full_like","fn "],["vtl","","vtl.html#range","fn "],["vtl","","vtl.html#seq","fn "],["vtl","","vtl.html#from_1d","fn "],["vtl","","vtl.html#from_2d","fn "],["vtl","","vtl.html#IteratorStrategy","enum "],["vtl","","vtl.html#TensorIterator","struct "],["vtl","","vtl.html#IteratorBuildData","struct "],["vtl","","vtl.html#TensorIterator[T]","type "],["vtl","","vtl.html#TensorIterator[T].next","fn (TensorIterator[T])"],["vtl","","vtl.html#TensorsIterator","struct "],["vtl","","vtl.html#TensorsIterator[T]","type "],["vtl","","vtl.html#TensorsIterator[T].next","fn (TensorsIterator[T])"],["vtl","","vtl.html#TensorAxisIterator","struct "],["vtl","","vtl.html#TensorAxisIterator[T]","type "],["vtl","","vtl.html#TensorAxisIterator[T].next","fn (TensorAxisIterator[T])"],["vtl","","vtl.html#bernoulli","fn "],["vtl","","vtl.html#binomial","fn "],["vtl","","vtl.html#exponential","fn "],["vtl","","vtl.html#NormalTensorData","struct "],["vtl","","vtl.html#normal","fn "],["vtl","","vtl.html#random","fn "],["vtl","","vtl.html#random_seed","fn "],["vtl","","vtl.html#AxisData","struct "],["vtl","","vtl.html#vstack","fn "],["vtl","","vtl.html#hstack","fn "],["vtl","","vtl.html#dstack","fn "],["vtl","","vtl.html#column_stack","fn "],["vtl","","vtl.html#stack","fn "],["vtl","","vtl.html#concatenate","fn "],["vtl","","vtl.html#MemoryFormat","enum "],["vtl","","vtl.html#Tensor","struct "],["vtl","","vtl.html#TensorDataType","type "],["vtl","","vtl.html#TensorDataType.string","fn (TensorDataType)"],["vtl","","vtl.html#TensorDataType.int","fn (TensorDataType)"],["vtl","","vtl.html#TensorDataType.i64","fn (TensorDataType)"],["vtl","","vtl.html#TensorDataType.i8","fn (TensorDataType)"],["vtl","","vtl.html#TensorDataType.i16","fn (TensorDataType)"],["vtl","","vtl.html#TensorDataType.u8","fn (TensorDataType)"],["vtl","","vtl.html#TensorDataType.u16","fn (TensorDataType)"],["vtl","","vtl.html#TensorDataType.u32","fn (TensorDataType)"],["vtl","","vtl.html#TensorDataType.u64","fn (TensorDataType)"],["vtl","","vtl.html#TensorDataType.f32","fn (TensorDataType)"],["vtl","","vtl.html#TensorDataType.f64","fn (TensorDataType)"],["vtl","","vtl.html#TensorDataType.bool","fn (TensorDataType)"],["vtl","","vtl.html#td","fn "],["vtl","","vtl.html#cast","fn "],["vtl","","vtl.html#AnyTensor","interface "],["vtl","","vtl.html#VclParams","struct "],["stats","","stats.html#AxisData","struct "],["stats","","stats.html#sum","fn "],["stats","","stats.html#sum_axis","fn "],["stats","","stats.html#sum_axis_with_dims","fn "],["stats","","stats.html#prod","fn "],["stats","","stats.html#prod_axis","fn "],["stats","","stats.html#prod_axis_with_dims","fn "],["stats","","stats.html#freq","fn "],["stats","","stats.html#mean","fn "],["stats","","stats.html#geometric_mean","fn "],["stats","","stats.html#harmonic_mean","fn "],["stats","","stats.html#median","fn "],["stats","","stats.html#mode","fn "],["stats","","stats.html#rms","fn "],["stats","","stats.html#population_variance","fn "],["stats","","stats.html#population_variance_mean","fn "],["stats","","stats.html#sample_variance","fn "],["stats","","stats.html#sample_variance_mean","fn "],["stats","","stats.html#population_stddev","fn "],["stats","","stats.html#population_stddev_mean","fn "],["stats","","stats.html#sample_stddev","fn "],["stats","","stats.html#sample_stddev_mean","fn "],["stats","","stats.html#absdev","fn "],["stats","","stats.html#absdev_mean","fn "],["stats","","stats.html#tss","fn "],["stats","","stats.html#tss_mean","fn "],["stats","","stats.html#min","fn "],["stats","","stats.html#max","fn "],["stats","","stats.html#minmax","fn "],["stats","","stats.html#min_index","fn "],["stats","","stats.html#max_index","fn "],["stats","","stats.html#minmax_index","fn "],["stats","","stats.html#range","fn "],["stats","","stats.html#covariance","fn "],["stats","","stats.html#covariance_mean","fn "],["stats","","stats.html#lag1_autocorrelation","fn "],["stats","","stats.html#lag1_autocorrelation_mean","fn "],["stats","","stats.html#kurtosis","fn "],["stats","","stats.html#kurtosis_mean_stddev","fn "],["stats","","stats.html#skew","fn "],["stats","","stats.html#skew_mean_stddev","fn "],["stats","","stats.html#quantile","fn "],["storage","","storage.html#CpuStorage","struct "],["storage","","storage.html#storage","fn "],["storage","","storage.html#from_array","fn "],["storage","","storage.html#CpuStorage[T]","type "],["storage","","storage.html#CpuStorage[T].get","fn (CpuStorage[T])"],["storage","","storage.html#CpuStorage[T].set","fn (CpuStorage[T])"],["storage","","storage.html#CpuStorage[T].fill","fn (CpuStorage[T])"],["storage","","storage.html#CpuStorage[T].clone","fn (CpuStorage[T])"],["storage","","storage.html#CpuStorage[T].like","fn (CpuStorage[T])"],["storage","","storage.html#CpuStorage[T].like_with_len","fn (CpuStorage[T])"],["storage","","storage.html#CpuStorage[T].offset","fn (CpuStorage[T])"],["storage","","storage.html#CpuStorage[T].to_array","fn (CpuStorage[T])"],];
